# 进程调度

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理时，就需要确定某种规则来决定处理这些任务的顺序，这就是 “调度” 研究的问题。在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个**进程**。处理机调度，就是从就绪队列中按照一定地算法选择一个进程并将处理机分配给它运行，以实现进程地并发执行。

:::info 狭义与广义
- 狭义调度指的是从队列选择一个进程
- 广义调度指的是从队列选择一个进程，并进行进程切换
:::

## 调度层次

由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序


### 低级调度

低级调度(进程调度)，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次

### 中级调度

引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量。  

暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。  

中级调度 (内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。  

每个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

:::info 七状态
暂时调到外存等待的进程状态为挂起状态 (挂起态，suspend)  
挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态  
:::

### 高级调度

高级调度 (作业调度) 。按一定的原则从外存上处于后备队列的作业中挑选一个(或多个) 作业给他们分配内存等必要资源，并建立相应的进程(建立PCB) ，以使它(们)获得竞争处理机的权利。

高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。

:::tip 与中级调度的区别
这里是是创建PCB和撤销PCB,中级调度会保留PCB至内存

更本质的来说,高级调度是创建进程,而中级调度只是切换进程的状态
:::

## 不能调度的情况

- 原语
- 进程处于OS内核程序临界区
- 在中断过程中进行进程切换(?)

## 调度的时机

- 主动
- 被动

## 调度的方式

- 剥夺
- 非剥夺

## 评价指标

- CPU 利用率: 指 CPU “忙碌” 的时间占总时间的比例
- 系统吞吐量: 单位时间内完成作业的数量
- 周转时间: 周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
- 带权周转时间=所有作业周转时间之和/作业数
- 带权周转时间: 周转时间/实际运行时间(在CPU上)
- 平均带权周转时间=所有作业带权周转时间和/作业数
- 响应时间: 指从用户提交请求到首次产生响应所用的时间
- 等待时间: 除去I/O等待的所有等待时间之和,从作业等待高度调度建立进程开始算

## 调度算法

### 先来先服务（FCFS，First Come First Server）

内容如题


### 短作业优先（SJF，Shortest Job First）

- 服务时间短的优先
- 可用于高级和低级调度,用于低级调度的称为(SPF,短进程优先)
- 非抢占(非剥夺),也就是说如果当前进程用时长的已经在运行,并不会让刚到达的运行短的任务抢上去
- 优点: 优化时间
- 缺点: 会产生饥饿现象,即运行时间长的线程可能会一直等待,同时运行时间为用户提供,不一定为实际运行时间

### 最短剩余时间优先算法 SRTN
抢占版的SJF和SPF

### 高响应比优先（HRRN， Highest Response Ratio Next）

- 综合考虑SJF和FCFS的均衡解法
- 根据响应比,越大越优先,响应比=(等待时间+要求服务时间)/要求服务时间
- 非抢占
- 不会导致饥饿
- 可用于高级和低级调度

### 时间片轮转调度算法（RR，Round-Robin）

- 分时
- 只用于进程调度(低级调度)
- 超时就换(基于时钟中断),强制剥夺
- 时间片过长退化为FCFS;过短切换开销过大

### 优先级调度算法

按照优先级来处理

### 多级反馈队列调度算法

设置多级就绪队列，各级队列优先级从高到低，时间片从小到大新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队尾只有第k 级队列为空时，才会为 k+1 级队头的进程分配时间片

抢占式的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾

优点: 快速响应,耗时短的进程很快完成,相对公平(没有优先级)

不估计运行时间,但可能会饥饿